<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nature & Focus Noise Generator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        #visual-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.6;
        }

        h1 { 
            margin-bottom: 30px; 
            color: #00d2be; 
            text-shadow: 0 0 10px rgba(0,0,0,0.5); 
            text-align: center;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* ‡ß´ ‡¶ï‡¶≤‡¶æ‡¶Æ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶≤‡ßã */
            gap: 15px;
            max-width: 900px;
            padding: 0 20px;
        }

        @media (max-width: 768px) {
            .grid { grid-template-columns: repeat(3, 1fr); }
        }
        @media (max-width: 480px) {
            .grid { grid-template-columns: repeat(2, 1fr); }
        }

        .sound-btn {
            background: rgba(51, 51, 51, 0.6);
            border: 1px solid #444;
            color: #ddd;
            padding: 15px 10px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .sound-btn span {
            font-size: 28px;
            margin-bottom: 8px;
        }

        /* Active State (On) */
        .sound-btn.active {
            background: rgba(0, 106, 78, 0.8);
            border-color: #00d2be;
            color: white;
            box-shadow: 0 0 15px rgba(0, 210, 190, 0.5);
            transform: scale(1.05);
        }

        .sound-btn.active-focus {
            background: rgba(88, 28, 135, 0.8);
            border-color: #c084fc;
            box-shadow: 0 0 15px rgba(192, 132, 252, 0.5);
        }

        .sound-btn:hover:not(.active):not(.active-focus) {
            border-color: #00d2be;
            background: rgba(70, 70, 70, 0.8);
            transform: translateY(-2px);
        }

        .volume-control {
            margin-top: 40px;
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255,255,255,0.1);
            padding: 15px 30px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        input[type=range] {
            width: 200px;
            cursor: pointer;
            accent-color: #00d2be;
        }
    </style>
</head>
<body>

    <canvas id="visual-canvas"></canvas>

    <h1>Nature & Study Noise Generator</h1>

    <div class="grid">
        <!-- Nature Sounds -->
        <button class="sound-btn" id="white" onclick="toggleSound('white')">
            <span>üì∫</span> White Noise
        </button>
        <button class="sound-btn" id="brown" onclick="toggleSound('brown')">
            <span>üèîÔ∏è</span> Brown Noise
        </button>
        <button class="sound-btn" id="rain" onclick="toggleSound('rain')">
            <span>üåßÔ∏è</span> Heavy Rain
        </button>
        <button class="sound-btn" id="waterfall" onclick="toggleSound('waterfall')">
            <span>üåä</span> Waterfall
        </button>
        <button class="sound-btn" id="wind" onclick="toggleSound('wind')">
            <span>üí®</span> Wind
        </button>
        <button class="sound-btn" id="fire" onclick="toggleSound('fire')">
            <span>üî•</span> Bonfire
        </button>
        <button class="sound-btn" id="thunder" onclick="toggleSound('thunder')">
            <span>‚ö°</span> Thunder
        </button>
        <button class="sound-btn" id="night" onclick="toggleSound('night')">
            <span>ü¶ó</span> Night
        </button>

        <!-- üî• Focus / Extreme Study Sounds -->
        <button class="sound-btn" id="focus" onclick="toggleSound('focus', true)">
            <span>üß†</span> Deep Focus
        </button>
        <button class="sound-btn" id="drone" onclick="toggleSound('drone', true)">
            <span>üåå</span> Space Drone
        </button>
    </div>

    <div class="volume-control">
        <span><i class="fa-solid fa-volume-high"></i> Volume: </span>
        <input type="range" min="0" max="100" value="30" oninput="changeVolume(this.value)">
    </div>

    <script>
        // --- ‡ßß. ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ ---
        let audioCtx;
        let activeNodes = {}; // ‡¶™‡ßç‡¶≤‡ßá ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ ‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø (‡¶è‡¶ñ‡¶® ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡ßß‡¶ü‡¶æ‡¶á ‡¶•‡¶æ‡¶ï‡¶¨‡ßá)
        let masterGain;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.3; 
                masterGain.connect(audioCtx.destination);
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function createNoiseBuffer(type) {
            const bufferSize = 2 * audioCtx.sampleRate;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);

            if (type === 'white' || type === 'rain' || type === 'wind') {
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
            } else if (type === 'brown' || type === 'waterfall' || type === 'fire' || type === 'thunder') {
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    output[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = output[i];
                    output[i] *= 3.5;
                }
            }
            return buffer;
        }

        // üî• ‡¶™‡ßç‡¶∞‡¶ß‡¶æ‡¶® ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® (‡¶∏‡¶ø‡¶ô‡ßç‡¶ó‡ßá‡¶≤ ‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶™‡ßç‡¶≤‡ßá ‡¶≤‡¶ú‡¶ø‡¶ï)
        function toggleSound(type, isStudyMode = false) {
            initAudio();
            const btn = document.getElementById(type);
            const isCurrentlyPlaying = !!activeNodes[type];

            // ‡ßß. ‡¶Ü‡¶ó‡ßá ‡¶ö‡¶≤‡¶æ ‡¶∏‡¶¨ ‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ
            for (let key in activeNodes) {
                if (activeNodes[key].stop) activeNodes[key].stop();
                if (activeNodes[key].source) activeNodes[key].source.stop();
                document.getElementById(key).classList.remove('active', 'active-focus');
                delete activeNodes[key];
            }

            // ‡ß®. ‡¶Ø‡¶¶‡¶ø ‡¶Ø‡ßá‡¶á ‡¶¨‡¶æ‡¶ü‡¶®‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶∏‡ßá‡¶ü‡¶æ‡¶á ‡¶Ü‡¶ó‡ßá ‡¶ö‡¶≤‡¶õ‡¶ø‡¶≤, ‡¶§‡¶¨‡ßá ‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶¨‡¶®‡ßç‡¶ß ‡¶π‡ßü‡ßá‡¶á ‡¶•‡¶æ‡¶ï‡¶¨‡ßá (Toggle Off)
            if (isCurrentlyPlaying) return;

            // ‡ß©. ‡¶®‡¶§‡ßÅ‡¶® ‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡¶æ
            if (isStudyMode) {
                btn.classList.add('active-focus'); // ‡¶∏‡ßç‡¶ü‡¶æ‡¶°‡¶ø ‡¶Æ‡ßã‡¶°‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶ï‡¶æ‡¶≤‡¶æ‡¶∞
            } else {
                btn.classList.add('active');
            }

            // ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ ‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶ú‡ßá‡¶®‡¶æ‡¶∞‡ßá‡¶ü‡¶∞
            if (type === 'night') {
                playCrickets(type);
                return;
            } else if (type === 'focus') {
                playDeepFocus(type);
                return;
            } else if (type === 'drone') {
                playSpaceDrone(type);
                return;
            }
            
            // ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶®‡¶Ø‡¶º‡ßá‡¶ú ‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶°
            const buffer = createNoiseBuffer(type);
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            const filter = audioCtx.createBiquadFilter();

            if (type === 'white') {
                source.connect(masterGain);
            } 
            else if (type === 'brown') {
                source.connect(masterGain);
            }
            else if (type === 'rain') {
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                source.connect(filter);
                filter.connect(masterGain);
            } 
            else if (type === 'waterfall') {
                filter.type = 'highpass';
                filter.frequency.value = 100;
                source.connect(filter);
                filter.connect(masterGain);
            }
            else if (type === 'wind') {
                filter.type = 'bandpass';
                filter.frequency.value = 400;
                filter.Q.value = 1; 
                source.connect(filter);
                filter.connect(masterGain);
                
                const lfo = audioCtx.createOscillator();
                lfo.frequency.value = 0.1; 
                const lfoGain = audioCtx.createGain();
                lfoGain.gain.value = 300;
                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);
                lfo.start();
                activeNodes[type] = { source: source, stop: () => { source.stop(); lfo.stop(); } }; 
                source.start();
                return;
            }
            else if (type === 'fire') {
                filter.type = 'lowpass';
                filter.frequency.value = 200; 
                source.connect(filter);
                filter.connect(masterGain);
            }
            else if (type === 'thunder') {
                filter.type = 'lowpass';
                filter.frequency.value = 150;
                source.connect(filter);
                filter.connect(masterGain);
            }

            source.start();
            activeNodes[type] = { source: source, stop: () => source.stop() };
        }

        // --- ‡¶∏‡ßç‡¶ü‡¶æ‡¶°‡¶ø ‡¶Æ‡ßã‡¶° ‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶∏‡¶ø‡¶®‡ßç‡¶•‡ßá‡¶∏‡¶ø‡¶∏ ---

        // üß† Deep Focus (Binaural Beats + Brown Noise)
        function playDeepFocus(type) {
            // Binaural Beats: Left 250Hz, Right 264Hz (14Hz Beta Wave for extreme concentration)
            const oscL = audioCtx.createOscillator();
            const oscR = audioCtx.createOscillator();
            const merger = audioCtx.createChannelMerger(2);
            
            oscL.type = 'sine';
            oscL.frequency.value = 250;
            oscR.type = 'sine';
            oscR.frequency.value = 264;

            oscL.connect(merger, 0, 0); // ‡¶¨‡¶æ‡¶Æ ‡¶ï‡¶æ‡¶®
            oscR.connect(merger, 0, 1); // ‡¶°‡¶æ‡¶® ‡¶ï‡¶æ‡¶®
            merger.connect(masterGain);

            // ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶ó‡ßç‡¶∞‡¶æ‡¶â‡¶®‡ßç‡¶°‡ßá ‡¶¨‡ßç‡¶∞‡¶æ‡¶â‡¶® ‡¶®‡ßü‡ßá‡¶ú (‡¶∏‡ßç‡¶Æ‡ßÅ‡¶• ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø)
            const buffer = createNoiseBuffer('brown');
            const noiseSrc = audioCtx.createBufferSource();
            noiseSrc.buffer = buffer;
            noiseSrc.loop = true;
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 150; // ‡¶ñ‡ßÅ‡¶¨ ‡¶®‡¶ø‡¶ö‡ßÅ ‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶°
            
            noiseSrc.connect(filter);
            filter.connect(masterGain);

            oscL.start();
            oscR.start();
            noiseSrc.start();

            activeNodes[type] = { 
                stop: () => { oscL.stop(); oscR.stop(); noiseSrc.stop(); } 
            };
        }

        // üåå Space Drone (Ambient Study Sound)
        function playSpaceDrone(type) {
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            
            osc1.type = 'sine'; osc1.frequency.value = 55; // Low hum
            osc2.type = 'triangle'; osc2.frequency.value = 110;

            const lfo = audioCtx.createOscillator();
            lfo.frequency.value = 0.05; // ‡¶ñ‡ßÅ‡¶¨ ‡¶ß‡ßÄ‡¶∞ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 10;

            lfo.connect(lfoGain);
            lfoGain.connect(osc2.frequency); // Pitch modulation
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 300;

            osc1.connect(filter);
            osc2.connect(filter);
            filter.connect(masterGain);

            osc1.start(); osc2.start(); lfo.start();

            activeNodes[type] = { 
                stop: () => { osc1.stop(); osc2.stop(); lfo.stop(); } 
            };
        }

        // ü¶ó Night / Crickets
        function playCrickets(type) {
            const osc = audioCtx.createOscillator();
            const modulator = audioCtx.createOscillator();
            const modGain = audioCtx.createGain();
            const amGain = audioCtx.createGain();

            osc.type = 'triangle';
            osc.frequency.value = 4500;
            modulator.type = 'square';
            modulator.frequency.value = 4;
            
            osc.connect(amGain);
            modulator.connect(amGain.gain);
            amGain.connect(masterGain);
            
            osc.start();
            modulator.start();

            activeNodes[type] = { 
                stop: () => { osc.stop(); modulator.stop(); } 
            };
        }

        function changeVolume(val) {
            if (masterGain) {
                masterGain.gain.value = val / 100;
            }
        }

        // --- ‡ß®. ‡¶≠‡¶ø‡¶°‡¶ø‡¶ì/‡¶Ö‡ßç‡¶Ø‡¶æ‡¶®‡¶ø‡¶Æ‡ßá‡¶∂‡¶® ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ (Canvas) ---
        const canvas = document.getElementById('visual-canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let particles = []; 
        let stars = []; 
        let flashOpacity = 0;
        let focusPulse = 0; // Deep Focus visual

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            initParticles();
            initStars();
        }
        window.addEventListener('resize', resize);
        
        function initStars() {
            stars = [];
            for(let i=0; i<200; i++) {
                stars.push({ x: Math.random() * width, y: Math.random() * height, size: Math.random() * 2, alpha: Math.random() });
            }
        }

        function initParticles() {
            particles = [];
            for(let i=0; i<500; i++) {
                particles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    speed: Math.random() * 10 + 5,
                    len: Math.random() * 20 + 10,
                    angle: Math.random() * Math.PI * 2,
                    life: Math.random() * 100
                });
            }
        }
        
        resize();

        function getActiveType() {
            return Object.keys(activeNodes)[0] || null; // ‡¶Ø‡ßá‡¶π‡ßá‡¶§‡ßÅ ‡¶è‡¶ï‡¶ü‡¶æ‡¶á ‡¶¨‡¶æ‡¶ú‡¶¨‡ßá
        }

        function animate() {
            requestAnimationFrame(animate);
            const activeType = getActiveType();

            // ‡¶ï‡ßç‡¶Ø‡¶æ‡¶®‡¶≠‡¶æ‡¶∏ ‡¶ï‡ßç‡¶≤‡¶ø‡ßü‡¶æ‡¶∞ ‡¶¨‡¶æ ‡¶ü‡ßç‡¶∞‡ßá‡¶á‡¶≤ ‡¶è‡¶´‡ßá‡¶ï‡ßç‡¶ü
            if (activeType === 'white' || activeType === 'brown' || activeType === 'night' || activeType === 'focus') {
                ctx.clearRect(0, 0, width, height);
            } else if (activeType === 'fire' || activeType === 'drone') {
                 ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
                 ctx.fillRect(0, 0, width, height);
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
                ctx.fillRect(0, 0, width, height);
            }

            if (!activeType) return;

            // ‡¶≠‡¶ø‡¶ú‡ßç‡¶Ø‡ßÅ‡¶Ø‡¶º‡¶æ‡¶≤ ‡¶°‡ßç‡¶∞ ‡¶ï‡¶∞‡¶æ
            if (activeType === 'white') drawStatic(2, 'white');
            else if (activeType === 'brown') drawStatic(20, '#5C4033');
            else if (activeType === 'rain') drawRain(false);
            else if (activeType === 'waterfall') drawRain(true);
            else if (activeType === 'wind') drawWind();
            else if (activeType === 'fire') drawFire();
            else if (activeType === 'thunder') drawThunder();
            else if (activeType === 'night') drawNight();
            else if (activeType === 'focus') drawFocus();
            else if (activeType === 'drone') drawSpace();
        }

        // --- ‡¶®‡¶§‡ßÅ‡¶® ‡¶°‡ßç‡¶∞‡ßü‡¶ø‡¶Ç ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ---
        function drawFocus() {
            focusPulse += 0.02;
            const size = Math.abs(Math.sin(focusPulse)) * 100 + 50;
            
            ctx.fillStyle = `rgba(147, 51, 234, 0.1)`;
            ctx.beginPath();
            ctx.arc(width/2, height/2, size * 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = `rgba(192, 132, 252, 0.5)`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(width/2, height/2, size, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawSpace() {
            for(let p of particles) {
                ctx.fillStyle = `rgba(59, 130, 246, ${Math.random() * 0.5})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
                p.x += Math.sin(p.life) * 0.5;
                p.y += Math.cos(p.life) * 0.5;
                p.life += 0.01;
            }
        }

        // --- ‡¶™‡ßÅ‡¶∞‡¶®‡ßã ‡¶°‡ßç‡¶∞‡ßü‡¶ø‡¶Ç ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ---
        function drawStatic(size, color) {
            for (let i = 0; i < 800; i++) {
                ctx.fillStyle = color === 'white' ? `rgba(255, 255, 255, ${Math.random()})` : `rgba(92, 64, 51, ${Math.random() * 0.5})`;
                const x = Math.floor(Math.random() * (width / size)) * size;
                const y = Math.floor(Math.random() * (height / size)) * size;
                ctx.fillRect(x, y, size, size);
            }
        }

        function drawRain(isWaterfall) {
            ctx.strokeStyle = isWaterfall ? 'rgba(135, 206, 235, 0.5)' : 'rgba(174, 194, 224, 0.5)';
            ctx.lineWidth = isWaterfall ? 3 : 1;
            ctx.beginPath();
            for(let p of particles) {
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x, p.y + p.len);
                p.y += isWaterfall ? p.speed * 2.5 : p.speed;
                if (p.y > height) { p.y = -p.len; p.x = Math.random() * width; }
            }
            ctx.stroke();
        }

        function drawWind() {
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.1)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let p of particles) {
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x + p.len * 2, p.y); 
                p.x += p.speed * 3; 
                if (p.x > width) { p.x = -p.len * 2; p.y = Math.random() * height; }
            }
            ctx.stroke();
        }

        function drawFire() {
            for(let p of particles) {
                if (p.life <= 0) {
                    p.x = width / 2 + (Math.random() * 100 - 50);
                    p.y = height;
                    p.life = Math.random() * 100;
                    p.speed = Math.random() * 2 + 1;
                }
                const r = 255; const g = Math.floor((p.life / 100) * 200); const b = 0; const a = p.life / 100;
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.random() * 5 + 2, 0, Math.PI * 2);
                ctx.fill();
                p.y -= p.speed; 
                p.x += Math.random() * 2 - 1; 
                p.life -= 1;
            }
        }

        function drawThunder() {
            if (Math.random() > 0.98) flashOpacity = 1; 
            if (flashOpacity > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${flashOpacity})`;
                ctx.fillRect(0, 0, width, height);
                flashOpacity -= 0.1; 
            } else {
                drawRain(false); 
            }
        }

        function drawNight() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, width, height);
            for(let s of stars) {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.abs(Math.sin(Date.now() * 0.001 + s.x))})`; 
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        animate();
    </script>
</body>
</html>
